-----------------------------------------------------------------------------------------
{-| Module      : HMinCaml.GenerateCode
    Copyright   : 
    License     : All Rights Reserved

    Maintainer  : 
    Stability   : 
    Portability : 
-}
-----------------------------------------------------------------------------------------

{-# OPTIONS_GHC -fglasgow-exts #-}

{-
Stack Layout:
-------------------            Increasing Address
| Temporaries     | <-- ESP             |
| Locals          |                     |
| Old EBP         | <-- EBP             |
| Return Address  |     / caller ESP    |
| Closure Address |                     |
| Argument        |                     | 
| Ret. Value Hole |                   \ | /
| ............... |                    \|/
|                 |                     V

Register Usage:
EAX: temporary working area
EBX: temporary working area
ECX: current closure address
EDX: temporary working area

ESI: heap pointer

ESP: stack top pointer
EBP: stack frame base pointer

Closure Layout:
----------------        |
| Code Pointer |      \ | /
| Variables    |       \|/
----------------        V
-}

-- TODO: floats!

module HMinCaml.GenerateCode(generateCode) where

import HMinCaml.Common
import HMinCaml.VariableLowering as V

import Char(isDigit)
import List(genericTake, genericIndex)
import Control.Monad(foldM_)
import Control.Monad.State(State, MonadState, get, modify, execState)

generateCode :: V.Program -> CompilerError String
generateCode = return . runCodeGenerator . generateCode'
  where
    generateCode' :: V.Program -> CodeGenerator ()
    generateCode' (V.Program fs f) = do
      let topLevelFunction = ("TopLevel", f)
      generateHeaderCode
      generateStartupCode topLevelFunction
      mapM_ (\(xf, f) -> do { writeCodeLine $ (functionLabel xf) ++ ":"; generateFunctionCode fs f }) 
            (topLevelFunction : fs)
      generateFormatString (returnType f)
      generateImportCode


newtype MemoryOffset = MemoryOffset Integer
                     deriving (Enum, Eq, Num)

instance Show MemoryOffset where
  show (MemoryOffset x) | x == 0 = ""
                        | x > 0  = "+" ++ s
                        | x < 0  = "-" ++ s
                        where s = (dropWhile (not . isDigit) (show x))

heapSize = 2 * 1024 * 1024 -- 2MB heap

functionLabel :: String -> String
functionLabel = ("Function" ++)

data CodeGeneratorState = CodeGeneratorState { code :: [String], labelIndex :: Integer }
newtype CodeGenerator a = CodeGenerator (State CodeGeneratorState a)
                        deriving (Monad, MonadState CodeGeneratorState)
      
runCodeGenerator :: CodeGenerator a -> String
runCodeGenerator (CodeGenerator g) = (unlines . code) (execState g (CodeGeneratorState { code = [], labelIndex = 0 }))
      
uniqueLabel :: CodeGenerator String
uniqueLabel = do
  label <- get >>= (return . labelIndex)
  modify (\state -> state { labelIndex = (labelIndex state) + 1 })
  return $ "Label" ++ (show $ label)
                  
writeCodeLine :: String -> CodeGenerator ()
writeCodeLine s = modify (\state -> state { code = (code state) ++ [s] })
       
writeCodeLines :: [String] -> CodeGenerator ()
writeCodeLines = mapM_ writeCodeLine
                        
generateHeaderCode :: CodeGenerator ()
generateHeaderCode = do
  writeCodeLines ["; Flat Assembler code: automatically generated by HMinCaml",
                  "format PE Console 4.0",
                  "",
                  "include 'import32.inc'",
                  ""]
    
generateStartupCode :: (Identifier, Function) -> CodeGenerator ()
generateStartupCode (xf, f) = do
  writeCodeLines ["push " ++ show heapSize,
                  "call [malloc]",
                  "mov esi, eax"]  -- Store the allocated heap pointer in ESI

  writeCodeLines ["sub esp, " ++ show (sizeOf (returnType f)), -- Allocate space for the return value
                  "push 0", -- Dummy argument
                  "push 0", -- Dummy closure address
                  "call " ++ functionLabel xf]
                  
  writeCodeLines ["push _formatString", -- I have contrived the stack layout of tuples to be such that it matches the C calling convention for printf :-)
                  "call [printf]",
                  "add esp, " ++ show (wordSize + sizeOf (returnType f))]
                  
  writeCodeLines ["push 0",
                  "call [exit]",
                  ""]
  
generateFormatString t = do
    let prolog = "_formatString db '"
    let format = formatString t
    let epilog = "',0"
    writeCodeLine $ prolog ++ format ++ epilog
  where
    formatString t =
      case t of
        IntegerType -> "%d"
        FloatingPointType -> "%f"
        BooleanType -> "%d"
        TupleType ts -> "(" ++ (intersperse ", " (map formatString ts)) ++ ")"
        FunctionType _ _ -> "<function at %d>"
        VariableType _ -> "<variable %d>" -- Usually (always?) indicates infinite loop..
                   
generateImportCode = do
  writeCodeLines ["data import",
                  "  library msvcrt,'MSVCRT.DLL'",
                  "  import msvcrt,\\",  -- Must be dereferenced by call since it actually makes a thunk table
	                "    exit,'exit',\\", 
	                "    printf,'printf',\\",
	                "    malloc,'malloc'",
	                "end data"]
                   
wordSize :: MemoryOffset
wordSize = MemoryOffset 4
     
class Sizeable a where
  sizeOf :: a -> MemoryOffset
    
instance Sizeable Type where
  sizeOf UnitType = wordSize
  sizeOf IntegerType = wordSize
  sizeOf FloatingPointType = wordSize
  sizeOf BooleanType = wordSize
  sizeOf (TupleType ts) = sum (map sizeOf ts)
  sizeOf (FunctionType _ _) = wordSize
  sizeOf (VariableType _) = wordSize -- Usually (always?) indicates infinite loop..

instance (Sizeable a) => Sizeable [a] where
  sizeOf xs = sum (map sizeOf xs)

generateFunctionCode :: V.Functions -> V.Function -> CodeGenerator ()
generateFunctionCode functions (V.Function { closure = closure, locals = locals, argument = argument, returnType = returnType, expression = e }) = do
  writeCodeLines ["push ebp",       -- Establish a stack frame by making the base pointer
                  "mov ebp, esp",   -- EBP point to the top of the stack, ESP.
                  "sub esp, " ++ show (sizeOf locals)] -- Allocate space for local variables
  recoverClosureAddress
  
  generateCode e
  
  -- Copy the return value from the top of the stack to the caller-allocated hole
  copy (\x -> "[esp" ++ show x ++ "]") (\x -> "[ebp" ++ show (x + returnValueHoleOffset) ++ "]") returnType
  
  writeCodeLines ["mov esp, ebp",   -- Destroy our stack frame by replacing the current stack
                  "pop ebp",        -- top with what it was initially (EBP) and restoring the old EBP
                  "ret " ++ show (2 * wordSize),  -- Return, clearing argument / closure address from the stack
                  ""]
  where
    returnValueHoleOffset = (3 * wordSize) + (sizeOf argument)
    
    recoverClosureAddress = writeCodeLine $ "mov ecx, [ebp" ++ show (2 * wordSize) ++ "]"
    
    generateCode :: V.Syntax -> CodeGenerator ()
    generateCode e = do
      writeCodeLine $ "; START " ++ show e
      case e of
        V.Unit -> push 0
        (V.IConstant c) -> push c
        (V.FConstant c) -> undefined
        (V.BConstant c) -> push (if c then 1 else 0)
        (V.Tuple rs) -> mapM_ pushFrom (reverse rs)
        (V.Variable r) -> pushFrom r
        (V.INegate r) -> do
          pushFrom r
          writeCodeLines ["pop eax",
                          "neg eax",
                          "push eax"]
        (V.IBinaryExpression op r1 r2) -> do
          pushFrom r2
          pushFrom r1
          writeCodeLines ["pop eax",
                          "pop ebx"]
          case op of
            Add      -> writeCodeLine "add eax, ebx"
            Subtract -> writeCodeLine "sub eax, ebx"
            Multiply -> writeCodeLine "imul eax, ebx"
            Divide   -> writeCodeLines ["mov edx, 0", -- IDIV divides EDX:EAX by SRC (in our case, EBX)
                                        "idiv ebx"]   -- hence clear EDX and then do the operation
          writeCodeLine "push eax"
        (V.FNegate r) -> undefined
        (V.FBinaryExpression op r1 r2) -> undefined
        (V.BNot r) -> do
          pushFrom r
          writeCodeLines ["pop eax",
                          "not eax",
                          "push eax"]
        (V.BEqual r1 r2) -> booleanTest "jne" r1 r2
        (V.BLessEqual r1 r2) -> booleanTest "jg" r1 r2
        (V.If rt e1 e2) -> do
          falseLabel <- uniqueLabel
          endLabel <- uniqueLabel
          pushFrom rt
          writeCodeLines ["pop eax",
                          "cmp eax, 0",
                          "je " ++ falseLabel]
          generateCode e1
          writeCodeLines ["jmp " ++ endLabel,
                          falseLabel ++ ":"]
          generateCode e2
          writeCodeLines [endLabel ++ ":",
                          "nop"]
        (V.LetVal r ev eb) -> do
          generateCode ev
          popTo r
          generateCode eb
        (V.LetTuple rs rv eb) -> do
          pushFrom rv
          mapM_ popTo rs
          generateCode eb
        (V.LetNewClosure r closure eb) -> do
          let xf = (function closure)
          let Just f = lookup xf functions
          writeCodeLines ["mov eax, esi",
                          "add esi, " ++ show ((sizeOf (V.closure f)) + wordSize),
                          "mov dword [eax], " ++ functionLabel xf]
          foldM_ writeVariableClosingCode wordSize (closeVariables closure)
          writeCodeLine "push eax"
          popTo r
          generateCode eb
          where
            writeVariableClosingCode offset r = do
              -- Copy the variable to close into the heap-allocated closure
              copy (referenceCode r) (\x -> "[eax" ++ show (x + offset) ++ "]") returnType
              return $ offset + sizeOf (referenceType r)
        (V.ApplyClosure (tr, r1) r2) -> do
          writeCodeLine $ "sub esp, " ++ show (sizeOf tr)
          pushFrom r2
          pushFrom r1
          writeCodeLines ["mov eax, [esp]",
                          "call dword [eax]"]
          recoverClosureAddress
      writeCodeLine $ "; END " ++ show e
    
    (!!!) = genericIndex
    
    push :: Integer -> CodeGenerator ()
    push c = writeCodeLine $ "push " ++ show c
    
    booleanTest :: String -> VariableReference -> VariableReference -> CodeGenerator ()
    booleanTest falseBranch r1 r2 = do
      falseLabel <- uniqueLabel
      pushFrom r2
      pushFrom r1
      writeCodeLines ["pop eax",
                      "pop ebx",
                      "mov edx, 0",
                      "cmp eax, ebx",
                      falseBranch ++ " " ++ falseLabel,
                      "mov edx, 1",
                      falseLabel ++ ":",
                      "push edx"]
    
    referenceType :: VariableReference -> Type
    referenceType (LocalVariable i) = locals!!!i
    referenceType (ClosureVariable i) = closure!!!i
    referenceType ArgumentVariable = argument
    
    localEBPOffset = (\i -> -(sum (map sizeOf (genericTake (i + 1) locals))))     -- Bottom address in memory of local relative to EBP
    closureECXOffset = (\i -> sum (map sizeOf (genericTake i closure)) + wordSize) -- Bottom address in memory of closure data relative to ECX
    argumentEBPOffset = 3 * wordSize                                              -- Bottom address in memory of argument data relative to EBP
    
    referenceCode :: VariableReference -> MemoryOffset -> String
    referenceCode (LocalVariable i) x = "[ebp" ++ show ((localEBPOffset i) + x) ++ "]"
    referenceCode (ClosureVariable i) x = "[ecx" ++ show ((closureECXOffset i) + x) ++ "]"
    referenceCode ArgumentVariable x = "[ebp" ++ show (argumentEBPOffset + x) ++ "]"
    
    pushFrom :: VariableReference -> CodeGenerator ()
    pushFrom = stackOperation "push" reverse
    
    popTo :: VariableReference -> CodeGenerator ()
    popTo = stackOperation "pop" id
    
    stackOperation :: String -> ([MemoryOffset] -> [MemoryOffset]) -> VariableReference -> CodeGenerator ()
    stackOperation op offsetChanger r = writeCodeLines $ map (\x -> op ++ " dword " ++ (referenceCode r x)) (offsetChanger [0,wordSize..sizeOf (referenceType r) - wordSize])
    
    copy :: (MemoryOffset -> String) -> (MemoryOffset -> String) -> Type -> CodeGenerator () -- Note: could be much more efficient using "rep movs"
    copy sourceFinder destinationFinder t =
      writeCodeLines (concatMap 
                       (\x -> 
                         ["mov edx, " ++ sourceFinder x,
                          "mov " ++ destinationFinder x ++ ", edx"]) 
                       [0,wordSize..sizeOf t - wordSize])